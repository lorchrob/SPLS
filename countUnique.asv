%{
NOTE: Must run 'readSpls32s' first!

Purpose:
  * Counts the number of essentially "unique" variants
    of each spls32 by applying 128 operations and seeing if the resulting
    spls32s are relabelings (applies these 128 operations to each spls32)

Parameters:
  * spls32s, a 3d array of all spls32s

Returns:
  * counts, an array of the unique symmetries of all the spls32s (first
    count applies to first spls32, etc.)
%}

function counts = countUnique(spls32s)
  counts = zeros(1, 1936);
  for i = 1:1936
    spls32 = spls32s(:,:,i);
    for j = 1:8
      for k = 1:8
        for x = 1:2        
          newSpls32 = rowOps(j, columnOps(k, transposeOps(x, spls32)));
          
          relabel(1) = newSpls32(3, 1);
          relabel(2) = newSpls32(3, 2);
          relabel(3) = newSpls32(3, 3);
          relabel(4) = newSpls32(4, 1);
          relabel(5) = newSpls32(4, 2);
          relabel(6) = newSpls32(4, 3);
          
          relabeled = zeros(6);
          
          for y = 1:6
            for z = 1:6
              relabeled(y, z) = relabel(spls32(y,z) + 1);
            end
          end
        
          diff = relabeled - newSpls32;
          diff = abs(diff);
          diff = sum(diff);
          diff = sum(diff);
          
          if diff == 0
            counts(i) = counts(i) + 1;
          end
        end
      end
    end
  end
end

%{
Applies specified row operations to spls32 to generate and return
newSpls32. 'num' specifies which operations to do:
  0 : identity (do nothing)
  1 : flip (r_2)
  2 : swap first two rows (r_0)
  3 : swap last two rows (r_1)
  4 : swap first two and last two rows (r_0 and r_1)
  5 : case 2, but with a flip (r_0, r_2)
  6 : case 3, but with a flip (r_1, r_2)
  7 : case 4, but with a flip (r_0, r_1, r_2)
%}
function newSpls32 = rowOps(num, spls32)
  % define matrices we multiply by to perform row operations
  r_0 = [0 1 0 0 0 0; 1 0 0 0 0 0; 0 0 1 0 0 0; 0 0 0 1 0 0; 0 0 0 0 1 0; 0 0 0 0 0 1];
  r_1 = [1 0 0 0 0 0; 0 1 0 0 0 0; 0 0 1 0 0 0; 0 0 0 1 0 0; 0 0 0 0 0 1; 0 0 0 0 1 0];
  r_0_and_r_1 = [0 1 0 0 0 0; 1 0 0 0 0 0; 0 0 1 0 0 0; 0 0 0 1 0 0; 0 0 0 0 0 1; 0 0 0 0 1 0];
  
  switch num
    % identity
    case 0
      newSpls32 = spls32;
    
    % r_2
    case 1
      newSpls32 = flip(spls32);
      
    % r_0  
    case 2
      newSpls32 = r_0 * spls32;
      
    % r_1  
    case 3
      newSpls32 = r_1 * spls32;
      
    % r_0, r_1
    case 4
      newSpls32 = r_0_and_r_1 * spls32;
      
    % r_0, r_2
    case 5
      newSpls32 = flip(spls32s);
      newSpls32 = r_0 * newSpls32;
      
    % r_1, r_2
    case 6
      newSpls32 = flip(spls32s);
      newSpls32 = r_1 * newSpls32;
      
    % r_0, r_1, r_2
    case 7
      newSpls32 = flip(spls32s);
      newSpls32 = r_0_and_r_1 * newSpls32;
  end
end

%{
Applies specified column operations to spls32 to generate and return
newSpls32. 'num' specifies which operations to do:
  0 : identity (do nothing)
  1 : flip (c_2)
  2 : swap first two columns (c_0)
  3 : swap last two columns (c_1)
  4 : swap first two and last two columns (c_0 and c_1)
  5 : case 2, but with a flip (c_0, c_2)
  6 : case 3, but with a flip (c_1, c_2)
  7 : case 4, but with a flip (c_0, c_1, c_2)
%}
function newSpls32 = columnOps(num, spls32)
  % define matrices we multiply by to perform column operations
  c_0 = [0 1 0 0 0 0; 1 0 0 0 0 0; 0 0 1 0 0 0; 0 0 0 1 0 0; 0 0 0 0 1 0; 0 0 0 0 0 1];
  c_1 = [1 0 0 0 0 0; 0 1 0 0 0 0; 0 0 1 0 0 0; 0 0 0 1 0 0; 0 0 0 0 0 1; 0 0 0 0 1 0];
  c_0_and_c_1 = [0 1 0 0 0 0; 1 0 0 0 0 0; 0 0 1 0 0 0; 0 0 0 1 0 0; 0 0 0 0 0 1; 0 0 0 0 1 0];
  
  switch num
    % identity
    case 0
      newSpls32 = spls32;
    
    % c_2
    case 1
      newSpls32 = fliplr(spls32);
      
    % c_0  
    case 2
      newSpls32 = spls32 * c_0;
      
    % c_1  
    case 3
      newSpls32 = spls32 * c_1;
      
    % c_0, c_1
    case 4
      newSpls32 = spls32 * c_0_and_c_1;
      
    % c_0, c_2
    case 5
      newSpls32 = fliplr(spls32);
      newSpls32 = newSpls32 * c_0;
      
    % c_1, c_2
    case 6
      newSpls32 = fliplr(spls32);
      newSpls32 = newSpls32 * c_1;
      
    % c_0, c_1, c_2
    case 7
      newSpls32 = fliplr(spls32);
        newSpls32(:,:,i) = newSpls32(:,:,i) * c_0_and_c_1;

  end
end


%{
Applies specified column operations to spls32 to generate and return
newSpls32. 'num' specifies which operations to do:
  0 : identity (do nothing)
  1 : transpose 
%}
function newSpls32s = transposeOps(num, spls32s)
  if num
    newSpls32s = permute(spls32s, [2, 1, 3]);
  else
    newSpls32s = spls32s;
  end
end